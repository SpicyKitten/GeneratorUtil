package generator;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import throwing.ThrowingRunnable;

public abstract class Generator<T> implements Iterator<T>
{
	private Lock lock = null;
	private Lock lock2 = null;
	private Semaphore semaphore = null;
	private T curr;
	private Thread execution;
	private Runnable onTermination = null;
	private Consumer<? super T> forEachAction = null;
	
	public Generator(Object... params)
	{
		execution = new Thread(() ->
		{
			try
			{
				T t = get(params);
				onTermination = ThrowingRunnable.of(execution::join);
				yield(t);
				getPermit();
			}
			catch(Exception unexpected)
			{
				onTermination = ThrowingRunnable.of(() ->
				{
					Exception e = new NoSuchElementException("Failed to retrieve element!");
					e.initCause(unexpected);
					throw e;
				});
				semaphore.release();
			}
		});
		execution.setDaemon(true);
	}
	
	@Override
	public final boolean hasNext()
	{
		return onTermination == null;
	}
	
	@Override
	public final T next()
	{
		if(!hasNext())
			throw new NoSuchElementException(
				"There are no more elements to be generated by this Generator!");
		if(semaphore == null && lock == null)
		{
			lock = new ReentrantLock();
			lock2 = new ReentrantLock();
			lock.lock();
			semaphore = new Semaphore(0);
			execution.start();
			getPermit();
			return curr;
		}
		lock2.lock();
		lock.unlock();
		getPermit();
		lock.lock();
		lock2.unlock();
		getPermit();
		if(onTermination != null)
		{
			lock.unlock();
			onTermination.run();
		}
		return curr;
	}
	
	protected final void yield(T t)
	{
		if(forEachAction != null)
		{
			forEachAction.accept(t);
			return;
		}
		curr = t;
		semaphore.release();
		lock.lock();
		lock.unlock();
		semaphore.release();
		lock2.lock();
		lock2.unlock();
	}
	
	private final void getPermit()
	{
		try
		{
			if(semaphore != null)
				semaphore.acquire();
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * Consumes all remaining elements possible. Obviously, don't use on
	 * infinite Generators.
	 */
	@Override
	public void forEachRemaining(Consumer<? super T> action)
	{
		Objects.requireNonNull(action);
		if(!hasNext())
			throw new IllegalStateException("Exhausted elements before calling forEach!");
		forEachAction = action;
		if(execution.isAlive())
		{
			lock.unlock();
		}
		else
		{
			try
			{
				execution.start();
			}
			catch(IllegalThreadStateException itse)
			{
				itse.initCause(// double checking
					new IllegalStateException("Can't exhaust elements and then call forEach!"));
				throw itse;
			}
		}
		ThrowingRunnable.of(execution::join).run();
		onTermination.run();
	}
	
	protected abstract T get(Object... objs);
}